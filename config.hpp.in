// Copyright 2019 Francesco Biscani (bluescarni@gmail.com)
//
// This file is part of the piranha library.
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef PIRANHA_CONFIG_HPP
#define PIRANHA_CONFIG_HPP

// Start of defines instantiated by CMake.
// clang-format off
#define PIRANHA_VERSION_STRING "@piranha_VERSION@"
#define PIRANHA_VERSION_MAJOR @piranha_VERSION_MAJOR@
#define PIRANHA_VERSION_MINOR @piranha_VERSION_MINOR@
@PIRANHA_ENABLE_LIBBACKTRACE@
// clang-format on
// End of defines instantiated by CMake.

// Detect compilers.
// NOTE: clang has to go first, as it might define __GNUC__ internally.
#if defined(__clang__)

#define PIRANHA_COMPILER_IS_CLANG

#elif defined(__GNUC__)

#define PIRANHA_COMPILER_IS_GCC

#else
// NOTE: additional compiler configurations go here.
#endif

// Concepts setup.
#if defined(__cpp_concepts)

#define PIRANHA_HAVE_CONCEPTS

#if defined(PIRANHA_COMPILER_IS_GCC)

// NOTE: currently, all GCC versions are still using the concepts TS syntax.
#define PIRANHA_CONCEPT_DECL concept bool

#else

#define PIRANHA_CONCEPT_DECL concept

#endif

#endif

// Detect 128bit integers, lifted from mp++. This is part of the public API.
#include <mp++/config.hpp>

#if defined(MPPP_HAVE_GCC_INT128)

#define PIRANHA_HAVE_GCC_INT128

#endif

// likely/unlikely macros, supported on GCC/clang.
#if defined(PIRANHA_COMPILER_IS_GCC) || defined(PIRANHA_COMPILER_IS_CLANG)

#define piranha_likely(x) __builtin_expect(static_cast<bool>(x), 1)
#define piranha_unlikely(x) __builtin_expect(static_cast<bool>(x), 0)

#else

#define piranha_likely(x) (x)
#define piranha_unlikely(x) (x)

#endif

// Detect the availability of std::string_view.
// NOTE: MSVC 2015 and earlier don't have a
// std::string_view implementation.
// NOTE: lift this from mp++ eventually.
#if !defined(_MSC_VER) || _MSC_VER >= 1910

#define PIRANHA_HAVE_STRING_VIEW

#endif

// thread_local configuration:
// - on clang/osx, this seems to be supported since xcode 8:
//   https://stackoverflow.com/questions/28094794/why-does-apple-clang-disallow-c11-thread-local-when-official-clang-supports
//   Note that additional conditions might be needed for iOS, if it ever comes
//   to that. Regarding the versioning, it seems the clang version macros are set
//   to the xcode version:
//   https://stackoverflow.com/questions/19387043/how-can-i-reliably-detect-the-version-of-clang-at-preprocessing-time
//   xcode 8.x is appleclang 8.y:
//   https://en.wikipedia.org/wiki/Xcode#8.x_series
// - at least some MinGW versions have a buggy thread_local implementation. This is shown by testing,
//   and reported in a bunch of places as well:
//   https://sourceforge.net/p/mingw-w64/bugs/445/
//   https://github.com/Alexpux/MINGW-packages/issues/2519
// - at least some early versions of the Intel compiler have a buggy implementation. This
//   came out from testing, but it might be fixed now.

#if (defined(__APPLE__) && __clang_major__ < 8) || defined(__MINGW32__) || defined(__INTEL_COMPILER)

#define PIRANHA_MAYBE_TLS

#else

// For the rest, we assume thread_local is available.
#define PIRANHA_MAYBE_TLS static thread_local
#define PIRANHA_HAVE_THREAD_LOCAL

#endif

#endif
